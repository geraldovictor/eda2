Uma árvore binária é uma estrutura onde se tem uma raiz que
tem o endereço de memória do elemento do "meio", e do lado
direito temos os elementos de maiores valores e do lado esquerdo
temos os elementos de menores valores
temos também em cada no o endereço das nos que ficam à direita de
cada nó.

O primeiro nó é a raiz e o ultimo nó é a folha

A altura de uma arvore é a distancia do no raiz até as folhas

A profundidade é a distancia dos nos folhas até o no raiz

Para inicializar a arvore devemos fazer o raiz do no apontar para nulo
em seguida para adicionar criamos um novo nó que recebe como parâmetro
a chave dentro da criação de um no alocamos esse novo nó do tipo PONT
esse novo no tem que seus filhos apontam para nulo (filhos da direita e da esquerda)
e o valor que foi passado para essa função qe é o da chave
Para adicionar usamos uma função que vê se o elemento está apontando pra nulo
Se estiver quer dizer que é o primeiro elemento
Então essa função retorna o proprio no

-------------------------------------------------
Aula 16/08

algoritmo de ordenação estável:
é o que mantem ordem relativa dos elementos estável
ex: quando quero manter uma ordem alfabetica e em seguida ordenar pelos numeros

typedef int Item;
#define key(A) (A)
#define less(A,B) (key(A)<key(B))
#define exch(A,B)
#define compexch(A,B) {less(B,A)exch(A,B)}
void selectionSort(item *v, int l, int r){
int i;
  for(i=l; i<r ; i++){
    int menor=i;
    for(j=i+1; j<r ; j++){
      if(less(v[j],v[menor]))
        menor=j;
    }
    exch(v[menor], v[i]]);
  }
}

void insertionSortSimple(Item *V, int l, int r){
  int i , j;
  for(i=l+1; i<r; i++){
    for(j=i; j>l ;j--){
      compexch(v[j-1], v[j]);
    }
  }
}

void InsertionSort(Item *V, int l, int r){
  int i,j;
  for (i=r; i>=l; i--) compexch(v[i],v[i-1]);
  for (i=l+1; i<=r ; i++){
  Item menor = v[i], j=i;
    while(less(menor, v[j-1])){
      v[j]=v[j-1];
      j--;
    }
    v[j]=menor;
  }
}
como inserir os elementos ordenadamente

por exemplo 2 32 4 56 53 423 35 3 5

2 4 32

----------------------------------------------------------
aula 03 19/08

static int separa(int *V, int l, int r){ //função static equilave a private em relação a OO
  int c = v[r];
  int j=l , k=0;
  for(int i=l; i <r ; i++){
  if(lesseq(V[i],c)) exch (v[i],v[j])
  j++;
  /*se o valor da minha posição atual for menor ou igual a esse meu pivô
  soma 1 no contador
  senão joga esse elemento pra ultima se não
  */

  }
  exch(v[p], v[r]);
  return j;
}
void quicksort(int *V, int l, int r){ // complexidade nlog n de casos médio , para aumentar a probabilidade de de ser n log n vc pega r, l e r+l/2 e usa a madianacomo pivô
  compexch(v[l],v[r]);//mediana
  compexch(v[(r+l/2),v[l]]);
  compexch(v[r],v[l]);
  if (ps> 2*lg(r)) return; // quando o elemento está demorando muito
  if(r-l>M){
    if(l<r){
      int j =separa(V,l,r);
      if(i-1-l> r- i +1){//qual caso tem menos elemento
        quicksort(V,l,j-1,ps+1);
        quicksort(V,j+1,r,ps+1);
      }else{
        quicksort(V,j+1,r,ps+1);
        quicksort(V,l,j-1,ps);
      }
    }
  }//else{
    //insertion(v,l,r);
  //}
}
void mediana(int *V, int l, int r){
  int j=separa(V,l,r);
  int meio = (l+r)/2;
  if(j>meio)
  mediana(V,l,j-1)
  else if(j<meio)
  mediana(V,j+1,r)
}

void selectionSort_r(Item *v, int l, int r ){
  if (l==r) return;

  int menor = acha_menor(v,l,l+1,r);
  exch(v[l], v[menor]);
  selectionSort_r(v,l+1,r);

}
int acha_menor(Item *v, int menor, int l, int r){
  if(l>r) return;
  if(less(v[l],v[menor])) menor =l;
  return acha_menor(v, menor, l+1, r);
}
void sort(Item *v, l,r){
  quicksort(v,l,r);
  insertion(v,l,r);
}
